import params
from collections import defaultdict
import numpy as np
from utils import *
from tree import Tree
from block import Block
from txn import txn
from event import *
from queue_manager import QueueManager


class Node:
	nid_counter = 0

	def __init__(self, is_fast = 1):
		"""
		nid: integer denoting id of the node
		is_fast: boolean denoting whether node is fast or slow
		peers: list of peers (Node Objects) of the given node
		tree: tree object representing blockchain for the given node
		t_blk: integer representing mining power
		txn_queue: queue containing txns yet to be inserted into blocks
		p2p_history: dictionary containing lists to avoid reducdancy in forwarding in p2p network
		overall_history: list of history of txns and blks we have dealt with recently
		"""
		self.nid = Node.nid_counter
		self.is_fast = is_fast
		self.is_selfish = 0
		self.peers = []
		self.tree = Tree()
		self.frac_cpu_power = 0 # not used anywhere, only in analysis
		self.t_blk = np.random.randint(10,20)
		self.txn_queue = []
		self.p2p_history = defaultdict(list)  #to avoid reducdancy in forwarding in p2p network
		self.overall_history = []  #history of txns and blks we have dealt with recently
		self.num_blocks = 0 # no of blocks generated by the node
		Node.nid_counter += 1

	def add_peer(self, node):
		"""
		node: Node Object that is peer of given node
		"""
		self.peers.append(node)

	def add_history(self, node, entry):
		"""
		keep a track of entries received by nodes
		"""
		if entry in self.p2p_history[node]:
			return

		self.p2p_history[node].append(entry)
		self.overall_history.append(entry)

		if len(self.p2p_history[node]) == 101:
			self.p2p_history[node] = self.p2p_history[node][1:]  #FIFO pop from history

		if len(self.overall_history) == 2001:
			self.overall_history = self.overall_history[1:]  #FIFO pop

	def send_msg(self, msg_obj, send_time, receiver, is_txn):
		"""
		calculate and return recv_time by simulating network delay
		"""
		rho = params.RHO[self.nid][receiver.nid]

		c = 0
		if self.is_fast == 1  and receiver.is_fast == 1:
			c = 100 * 1024  #100 Mbps = 100 * 1024 Kbps
		else:
			c = 5 * 1024   #5 Mbps

		d = sample_exponential((96 / c))

		msg_len = 0
		if is_txn == 1:
			msg_len = 1 #1 KB

		else:
			msg_len = 1 * msg_obj.size() #1MB = 1024 KB	

		delay = rho + ((msg_len * 8) / c) + d  # * 8 because bytes to bits
		recv_time = send_time + delay

		id = -1
		if is_txn==1:   #add txns and blks to history
			id = msg_obj.txn_id
			self.add_history(receiver, (id, -1))

		else:
			id = msg_obj.bid
			self.add_history(receiver, (-1, id))

		return recv_time
	
	def create_coinbase_txn(self, txn_time):
		"""
		create and return a coinbase txn
		txn_time: time of txn
		"""
		amount = params.COINBASE_AMOUNT
		txn_obj = txn(-1, self.nid, amount, txn_time, is_coinbase = 1)
		return txn_obj

	def create_txn(self, time_offset = 0):
		"""
		creates a txn whose sender is self, receiver and amount are random
		the txn is valid at the time of creation
		time_offset: time at which txn is being created
		"""
		balances = self.tree.get_balances(Block.bid_to_obj[self.tree.leaf_bid].pbid)
		txn_time = time_offset + sample_exponential(params.MEAN_INTERARRIVAL_TIME)
		receiver_id = sample_randint(0, params.N-1, self.nid)
		amount = sample_randint(0, balances[self.nid])
		txn_obj = txn(self.nid, receiver_id, amount, txn_time)
		QueueManager.insert_txn_create_event(txn_time, txn_obj, self)

	def receive_txn(self, txn_obj, recv_time, sender):
		"""
		receive the txn and check if it already exists in txn pool
		if it does not, add it to pool and forward it to peers
		recv_time: txn receive time
		sender: sender of txn
		"""
		id = txn_obj.txn_id
		if txn_obj in self.txn_queue:  #txn was recieved and processed before
			return

		self.txn_queue.append(txn_obj)
		self.add_history(sender, (id, -1))

		for peer in self.peers:     #forward to peers after processing
			if (id, -1) not in self.p2p_history[peer]:
				peer_recv_time = self.send_msg(txn_obj, recv_time, peer, 1)
				QueueManager.insert_txn_receive_event(peer_recv_time, txn_obj, peer, self)

	def create_block(self, pbid, time_offset = 0):
		"""
		given the pbid, creates an event at future time for creation of subsequent block
		before adding the event, the block is checked for valid txns, and only valid txns
		are inserted into the block
		time_offset: simulation time at which this function is called
		"""
		block = Block(pbid, self.nid)

		balances = self.tree.get_balances(block.pbid)

		while self.txn_queue and len(block.txns) < params.MAX_txn_IN_BLOCK:
			txn = self.txn_queue[0]
			self.txn_queue.pop(0)

			assert txn.sender_id >= 0 # should not have any txn with -1 sender id over here

			# validate txn before inserting in block
			if txn.amount <= balances[txn.sender_id]:
				block.txns.append(txn)
				balances[txn.sender_id] -= txn.amount
			
		broadcast_time = time_offset + sample_exponential(self.t_blk)

		# get mining fee
		coinbase_txn = self.create_coinbase_txn(broadcast_time)
		block.txns.append(coinbase_txn)
		QueueManager.insert_block_create_event(broadcast_time, block, self)
	
	def broadcast_block(self, block, event_time):
		"""
		checks if the block should be broadcasted
		if yes, block is broadcasted
		"""
		# check if node has same longest chain at time tk + Tk as it
		# had at tk (time of creation of block)
		if self.tree.max_depth != (block.depth - 1):
			return
		
		self.num_blocks += 1
		# add block to its blockchain
		self.receive_block(block, event_time, self)

	def receive_block(self, block, time, sender):
		"""
		receive block -> check if it is not the one that has already been received ->
		validate txns -> remove txns from current txn pool -> add block
		to our blockchain -> start mining new block if the block created longest chain ->
		broadcast the block to peers
		"""
		id = block.bid
		if (-1, id) in self.overall_history:  #already processed and forwarded this blk
			return

		# validate block
		balances = self.tree.get_balances(block.pbid)
		for txn in block.txns:
			if txn.sender_id >= 0 and txn.amount > balances[txn.sender_id]:
				return
			balances[txn.sender_id] -= txn.amount

		# remove txns in inserted block from txn queue
		for txn in block.txns:
			if txn in self.txn_queue:
				self.txn_queue.remove(txn)

		self.tree.addEdge(block.pbid, block.bid, time)
		if self.tree.new_longest_chain:
			self.create_block(block.bid, time)

		if sender in self.p2p_history:  #when called from broadcast_block, sender is the same node, which is not in history
			self.add_history(sender, (-1, id))

		for peer in self.peers:  #forward to peers after verifying and processing
			if (-1, id) not in self.p2p_history[peer]:
				peer_recv_time = self.send_msg(block, time, peer, 0)
				QueueManager.insert_block_receive_event(peer_recv_time, block, peer, self)

	def __repr__(self):
		return f"Node {self.nid}"
